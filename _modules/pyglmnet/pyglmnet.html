

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pyglmnet.pyglmnet &mdash; pyglmnet 1.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="pyglmnet 1.1 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> pyglmnet
          

          
          </a>

          
            
            
              <div class="version">
                1.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../start.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cheatsheet.html">Cheatsheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../auto_examples/index.html">Examples Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Developer Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../whats_new.html">Release notes</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">pyglmnet</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
        <li><a href="../index.html">Module code</a> &raquo;</li>
      
    <li>pyglmnet.pyglmnet</li>
    <li class="wy-breadcrumbs-aside">
      
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyglmnet.pyglmnet</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Python implementation of elastic-net regularized GLMs.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">expit</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">norm</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="n">logger</span><span class="p">,</span> <span class="n">set_log_level</span><span class="p">,</span> <span class="n">_check_params</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">is_classifier</span><span class="p">,</span> <span class="n">check_version</span>


<span class="n">ALLOWED_DISTRS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> <span class="s1">&#39;binomial&#39;</span><span class="p">,</span> <span class="s1">&#39;softplus&#39;</span><span class="p">,</span> <span class="s1">&#39;poisson&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;probit&#39;</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_probit_g1</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">pdfz</span><span class="p">,</span> <span class="n">cdfz</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">res</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">thresh</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="o">-</span><span class="n">pdfz</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">thresh</span><span class="p">]</span> <span class="o">/</span> <span class="n">z</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">thresh</span><span class="p">])</span>
    <span class="n">res</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">cdfz</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">])</span>
    <span class="n">res</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">pdfz</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">/</span> <span class="n">z</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">_probit_g2</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">pdfz</span><span class="p">,</span> <span class="n">cdfz</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">res</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">thresh</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdfz</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">thresh</span><span class="p">]</span> <span class="o">/</span> <span class="n">z</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">thresh</span><span class="p">]</span>
    <span class="n">res</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cdfz</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">])</span>
    <span class="n">res</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pdfz</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">/</span> <span class="n">z</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">_probit_g3</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">pdfz</span><span class="p">,</span> <span class="n">cdfz</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">res</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">thresh</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">z</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">thresh</span><span class="p">]</span>
    <span class="n">res</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">=</span> \
        <span class="n">pdfz</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">/</span> <span class="n">cdfz</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">]</span>
    <span class="n">res</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdfz</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">_probit_g4</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">pdfz</span><span class="p">,</span> <span class="n">cdfz</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">res</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">thresh</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdfz</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">thresh</span><span class="p">]</span>
    <span class="n">res</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">=</span> \
        <span class="n">pdfz</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cdfz</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">])</span>
    <span class="n">res</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">_probit_g5</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">pdfz</span><span class="p">,</span> <span class="n">cdfz</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">res</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">thresh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">z</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">thresh</span><span class="p">]</span>
    <span class="n">res</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">=</span> \
        <span class="n">z</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">*</span> <span class="n">pdfz</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">/</span> \
        <span class="n">cdfz</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">pdfz</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">/</span>
                                     <span class="n">cdfz</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">res</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">*</span> <span class="n">pdfz</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">+</span> <span class="n">pdfz</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">_probit_g6</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">pdfz</span><span class="p">,</span> <span class="n">cdfz</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">res</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">thresh</span><span class="p">]</span> <span class="o">=</span> \
        <span class="n">pdfz</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">thresh</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">thresh</span><span class="p">]</span> <span class="o">*</span> <span class="n">pdfz</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">thresh</span><span class="p">]</span>
    <span class="n">res</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">=</span> \
        <span class="p">(</span><span class="n">pdfz</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cdfz</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">]))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> \
        <span class="n">z</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">*</span> <span class="n">pdfz</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">/</span> \
        <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cdfz</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">])</span>
    <span class="n">res</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">z</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">_z</span><span class="p">(</span><span class="n">beta0</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">fit_intercept</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute z to be passed through non-linearity&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fit_intercept</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">beta0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">beta0</span><span class="p">,</span> <span class="n">beta</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">z</span>


<span class="k">def</span> <span class="nf">_lmb</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">beta0</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">fit_intercept</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Conditional intensity function.&quot;&quot;&quot;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">_z</span><span class="p">(</span><span class="n">beta0</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">fit_intercept</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_mu</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">fit_intercept</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_mu</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">fit_intercept</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The non-linearity (inverse link).&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">distr</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;softplus&#39;</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">]:</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;poisson&#39;</span><span class="p">:</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">beta0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">eta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span> <span class="k">if</span> <span class="n">fit_intercept</span> <span class="k">else</span> <span class="mf">0.</span>
        <span class="n">mu</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">eta</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">eta</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span> <span class="o">+</span> <span class="n">beta0</span>
        <span class="n">mu</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;=</span> <span class="n">eta</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;=</span> <span class="n">eta</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">z</span>
    <span class="k">elif</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;binomial&#39;</span><span class="p">:</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">expit</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;probit&#39;</span><span class="p">:</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mu</span>


<span class="k">def</span> <span class="nf">_grad_mu</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">eta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Derivative of the non-linearity.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">distr</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;softplus&#39;</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">]:</span>
        <span class="n">grad_mu</span> <span class="o">=</span> <span class="n">expit</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;poisson&#39;</span><span class="p">:</span>
        <span class="n">grad_mu</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">grad_mu</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">eta</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">z</span><span class="p">)[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">eta</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span>
        <span class="n">grad_mu</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;=</span> <span class="n">eta</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;=</span> <span class="n">eta</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
        <span class="n">grad_mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;binomial&#39;</span><span class="p">:</span>
        <span class="n">grad_mu</span> <span class="o">=</span> <span class="n">expit</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">expit</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">distr</span> <span class="ow">in</span> <span class="s1">&#39;probit&#39;</span><span class="p">:</span>
        <span class="n">grad_mu</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">grad_mu</span>


<span class="k">def</span> <span class="nf">_logL</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y_hat</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The log likelihood.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">distr</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;softplus&#39;</span><span class="p">,</span> <span class="s1">&#39;poisson&#39;</span><span class="p">]:</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">spacing</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">logL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">y_hat</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span> <span class="o">-</span> <span class="n">y_hat</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
        <span class="n">logL</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="n">y_hat</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;binomial&#39;</span><span class="p">:</span>

        <span class="c1"># prevents underflow</span>
        <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">z</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">z</span><span class="p">)))</span>
        <span class="c1"># for scoring</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">y_hat</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y_hat</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;probit&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pdfz</span><span class="p">,</span> <span class="n">cdfz</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">logL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">_probit_g1</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">pdfz</span><span class="p">,</span> <span class="n">cdfz</span><span class="p">)</span> <span class="o">+</span>
                          <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">_probit_g2</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">pdfz</span><span class="p">,</span> <span class="n">cdfz</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">y_hat</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y_hat</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span>
        <span class="c1"># see</span>
        <span class="c1"># https://www.statistics.ma.tum.de/fileadmin/w00bdb/www/czado/lec8.pdf</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># shape parameter, exponential for now</span>
        <span class="n">logL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">nu</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">y</span> <span class="o">/</span> <span class="n">y_hat</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">y_hat</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">logL</span>


<span class="k">def</span> <span class="nf">_penalty</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Tau</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The penalty.&quot;&quot;&quot;</span>
    <span class="c1"># Combine L1 and L2 penalty terms</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">_L2penalty</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">Tau</span><span class="p">)</span> <span class="o">+</span> \
        <span class="n">alpha</span> <span class="o">*</span> <span class="n">_L1penalty</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">P</span>


<span class="k">def</span> <span class="nf">_L2penalty</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">Tau</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The L2 penalty.&quot;&quot;&quot;</span>
    <span class="c1"># Compute the L2 penalty</span>
    <span class="k">if</span> <span class="n">Tau</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Ridge=like penalty</span>
        <span class="n">L2penalty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Tikhonov penalty</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Tau</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">beta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span>
                <span class="n">Tau</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">beta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Tau should be (n_features x n_features)&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">L2penalty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Tau</span><span class="p">,</span> <span class="n">beta</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">L2penalty</span>


<span class="k">def</span> <span class="nf">_L1penalty</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The L1 penalty.&quot;&quot;&quot;</span>
    <span class="c1"># Compute the L1 penalty</span>
    <span class="k">if</span> <span class="n">group</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Lasso-like penalty</span>
        <span class="n">L1penalty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Group sparsity case: apply group sparsity operator</span>
        <span class="n">group_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="n">L1penalty</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">group_id</span> <span class="ow">in</span> <span class="n">group_ids</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">group_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">L1penalty</span> <span class="o">+=</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="n">group</span> <span class="o">==</span> <span class="n">group_id</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">L1penalty</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="n">group</span> <span class="o">==</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">L1penalty</span>


<span class="k">def</span> <span class="nf">_loss</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">Tau</span><span class="p">,</span> <span class="n">reg_lambda</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span>
          <span class="n">fit_intercept</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define the objective function for elastic net.&quot;&quot;&quot;</span>
    <span class="n">n_samples</span><span class="p">,</span> <span class="n">n_features</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">_z</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">X</span><span class="p">,</span> <span class="n">fit_intercept</span><span class="p">)</span>
    <span class="n">y_hat</span> <span class="o">=</span> <span class="n">_mu</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">fit_intercept</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">n_samples</span> <span class="o">*</span> <span class="n">_logL</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y_hat</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fit_intercept</span><span class="p">:</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">_penalty</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">Tau</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">_penalty</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Tau</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="o">-</span><span class="n">L</span> <span class="o">+</span> <span class="n">reg_lambda</span> <span class="o">*</span> <span class="n">P</span>
    <span class="k">return</span> <span class="n">J</span>


<span class="k">def</span> <span class="nf">_L2loss</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">Tau</span><span class="p">,</span> <span class="n">reg_lambda</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span>
            <span class="n">fit_intercept</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Define the objective function for elastic net.&quot;&quot;&quot;</span>
    <span class="n">n_samples</span><span class="p">,</span> <span class="n">n_features</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">_z</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">X</span><span class="p">,</span> <span class="n">fit_intercept</span><span class="p">)</span>
    <span class="n">y_hat</span> <span class="o">=</span> <span class="n">_mu</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">fit_intercept</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">n_samples</span> <span class="o">*</span> <span class="n">_logL</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y_hat</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fit_intercept</span><span class="p">:</span>
        <span class="n">P</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">_L2penalty</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">Tau</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">P</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">_L2penalty</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">Tau</span><span class="p">)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="o">-</span><span class="n">L</span> <span class="o">+</span> <span class="n">reg_lambda</span> <span class="o">*</span> <span class="n">P</span>
    <span class="k">return</span> <span class="n">J</span>


<span class="k">def</span> <span class="nf">_grad_L2loss</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">Tau</span><span class="p">,</span> <span class="n">reg_lambda</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span>
                 <span class="n">fit_intercept</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The gradient.&quot;&quot;&quot;</span>
    <span class="n">n_samples</span><span class="p">,</span> <span class="n">n_features</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">Tau</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fit_intercept</span><span class="p">:</span>
            <span class="n">Tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">beta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">InvCov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Tau</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Tau</span><span class="p">)</span>

    <span class="n">z</span> <span class="o">=</span> <span class="n">_z</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">X</span><span class="p">,</span> <span class="n">fit_intercept</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">_mu</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">fit_intercept</span><span class="p">)</span>
    <span class="n">grad_mu</span> <span class="o">=</span> <span class="n">_grad_mu</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">eta</span><span class="p">)</span>

    <span class="n">grad_beta0</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="k">if</span> <span class="n">distr</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;poisson&#39;</span><span class="p">,</span> <span class="s1">&#39;softplus&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">fit_intercept</span><span class="p">:</span>
            <span class="n">grad_beta0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">grad_mu</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">grad_mu</span> <span class="o">/</span> <span class="n">mu</span><span class="p">)</span>
        <span class="n">grad_beta</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">grad_mu</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">-</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">y</span> <span class="o">*</span> <span class="n">grad_mu</span> <span class="o">/</span> <span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fit_intercept</span><span class="p">:</span>
            <span class="n">grad_beta0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">mu</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">grad_mu</span><span class="p">)</span>
        <span class="n">grad_beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">mu</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span> <span class="o">*</span> <span class="n">grad_mu</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">elif</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;binomial&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fit_intercept</span><span class="p">:</span>
            <span class="n">grad_beta0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mu</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">grad_beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">mu</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="k">elif</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;probit&#39;</span><span class="p">:</span>
        <span class="n">grad_logl</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">_probit_g3</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">grad_mu</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span> <span class="o">-</span>
                     <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">_probit_g4</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">grad_mu</span><span class="p">,</span> <span class="n">mu</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">fit_intercept</span><span class="p">:</span>
            <span class="n">grad_beta0</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">grad_logl</span><span class="p">)</span>
        <span class="n">grad_beta</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">grad_logl</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="k">elif</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="n">grad_logl</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">/</span> <span class="n">mu</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">mu</span><span class="p">)</span> <span class="o">*</span> <span class="n">grad_mu</span>
        <span class="k">if</span> <span class="n">fit_intercept</span><span class="p">:</span>
            <span class="n">grad_beta0</span> <span class="o">=</span> <span class="o">-</span><span class="n">nu</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">grad_logl</span><span class="p">)</span>
        <span class="n">grad_beta</span> <span class="o">=</span> <span class="o">-</span><span class="n">nu</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">grad_logl</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="n">grad_beta0</span> <span class="o">*=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">n_samples</span>
    <span class="n">grad_beta</span> <span class="o">*=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">n_samples</span>
    <span class="k">if</span> <span class="n">fit_intercept</span><span class="p">:</span>
        <span class="n">grad_beta</span> <span class="o">+=</span> <span class="n">reg_lambda</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">InvCov</span><span class="p">,</span> <span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_features</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">))</span>
        <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">grad_beta0</span>
        <span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">grad_beta</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">grad_beta</span> <span class="o">+=</span> <span class="n">reg_lambda</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">InvCov</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">grad_beta</span>

    <span class="k">return</span> <span class="n">g</span>


<span class="k">def</span> <span class="nf">_gradhess_logloss_1d</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">xk</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">fit_intercept</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute gradient (1st derivative)</span>
<span class="sd">    and Hessian (2nd derivative)</span>
<span class="sd">    of log likelihood for a single coordinate.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xk: float</span>
<span class="sd">        (n_samples,)</span>
<span class="sd">    y: float</span>
<span class="sd">        (n_samples,)</span>
<span class="sd">    z: float</span>
<span class="sd">        (n_samples,)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gk: gradient, float:</span>
<span class="sd">        (n_features + 1,)</span>
<span class="sd">    hk: float:</span>
<span class="sd">        (n_features + 1,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">xk</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;softplus&#39;</span><span class="p">:</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">_mu</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">fit_intercept</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">expit</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">gk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="n">xk</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">s</span> <span class="o">/</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">xk</span><span class="p">)</span>

        <span class="n">grad_s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span>
        <span class="n">grad_s_by_mu</span> <span class="o">=</span> <span class="n">grad_s</span> <span class="o">/</span> <span class="n">mu</span> <span class="o">-</span> <span class="n">s</span> <span class="o">/</span> <span class="p">(</span><span class="n">mu</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">hk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">grad_s</span> <span class="o">*</span> <span class="n">xk</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">grad_s_by_mu</span> <span class="o">*</span> <span class="n">xk</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;poisson&#39;</span><span class="p">:</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">_mu</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">fit_intercept</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">expit</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">gk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">mu</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;=</span> <span class="n">eta</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;=</span> <span class="n">eta</span><span class="p">])</span> <span class="o">*</span>
                    <span class="n">xk</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;=</span> <span class="n">eta</span><span class="p">])</span> <span class="o">+</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span> <span class="o">*</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">eta</span><span class="p">]</span> <span class="o">/</span> <span class="n">mu</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">eta</span><span class="p">])</span> <span class="o">*</span>
                   <span class="n">xk</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">eta</span><span class="p">])</span>
        <span class="n">hk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mu</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;=</span> <span class="n">eta</span><span class="p">]</span> <span class="o">*</span> <span class="n">xk</span><span class="p">[</span><span class="n">z</span> <span class="o">&lt;=</span> <span class="n">eta</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">eta</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">mu</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">eta</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span>
                   <span class="p">(</span><span class="n">xk</span><span class="p">[</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">eta</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
        <span class="n">gk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">z</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">xk</span><span class="p">)</span>
        <span class="n">hk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xk</span> <span class="o">*</span> <span class="n">xk</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;binomial&#39;</span><span class="p">:</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">_mu</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">fit_intercept</span><span class="p">)</span>
        <span class="n">gk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">mu</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">xk</span><span class="p">)</span>
        <span class="n">hk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mu</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">*</span> <span class="n">xk</span> <span class="o">*</span> <span class="n">xk</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;probit&#39;</span><span class="p">:</span>
        <span class="n">pdfz</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">cdfz</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">gk</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">y</span> <span class="o">*</span> <span class="n">_probit_g3</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">pdfz</span><span class="p">,</span> <span class="n">cdfz</span><span class="p">)</span> <span class="o">-</span>
                      <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">_probit_g4</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">pdfz</span><span class="p">,</span> <span class="n">cdfz</span><span class="p">))</span> <span class="o">*</span> <span class="n">xk</span><span class="p">)</span>
        <span class="n">hk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">y</span> <span class="o">*</span> <span class="n">_probit_g5</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">pdfz</span><span class="p">,</span> <span class="n">cdfz</span><span class="p">)</span> <span class="o">+</span>
                     <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">_probit_g6</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">pdfz</span><span class="p">,</span> <span class="n">cdfz</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">xk</span> <span class="o">*</span> <span class="n">xk</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;cdfast is not implemented for Gamma &#39;</span>
                                  <span class="s1">&#39;distribution&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">n_samples</span> <span class="o">*</span> <span class="n">gk</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">n_samples</span> <span class="o">*</span> <span class="n">hk</span>


<span class="k">def</span> <span class="nf">simulate_glm</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">beta0</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">sample</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simulate target data under a generative model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    distr: str</span>
<span class="sd">        distribution</span>
<span class="sd">    beta0: float</span>
<span class="sd">        intercept coefficient</span>
<span class="sd">    beta: array</span>
<span class="sd">        coefficients of shape (n_features,)</span>
<span class="sd">    X: array</span>
<span class="sd">        design matrix of shape (n_samples, n_features)</span>
<span class="sd">    eta: float</span>
<span class="sd">        parameter for poisson non-linearity</span>
<span class="sd">    random_state: float</span>
<span class="sd">        random state</span>
<span class="sd">    sample: bool</span>
<span class="sd">        If True, sample from distribution. Otherwise, return</span>
<span class="sd">        conditional intensity function</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y: array</span>
<span class="sd">        simulated target data of shape (n_samples,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">distr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ALLOWED_DISTRS</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;distr&#39; must be in </span><span class="si">%s</span><span class="s2">, got </span><span class="si">%s</span><span class="s2">&quot;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">ALLOWED_DISTRS</span><span class="p">),</span> <span class="n">distr</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">beta0</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;beta0&#39; must be float, got </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">beta0</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">beta</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;beta&#39; must be 1D, got </span><span class="si">%d</span><span class="s2">D&quot;</span> <span class="o">%</span> <span class="n">beta</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">sample</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_lmb</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">beta0</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">eta</span><span class="p">)</span>

    <span class="n">_random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;softplus&#39;</span> <span class="ow">or</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;poisson&#39;</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">_random_state</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span><span class="n">_lmb</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">beta0</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">eta</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">_random_state</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">_lmb</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">beta0</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">eta</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;binomial&#39;</span> <span class="ow">or</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;probit&#39;</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">_random_state</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">_lmb</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">beta0</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">eta</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">_lmb</span><span class="p">(</span><span class="n">distr</span><span class="p">,</span> <span class="n">beta0</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">eta</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span>


<div class="viewcode-block" id="GLM"><a class="viewcode-back" href="../../api.html#pyglmnet.GLM">[docs]</a><span class="k">class</span> <span class="nc">GLM</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for estimating regularized generalized linear models (GLM).</span>
<span class="sd">    The regularized GLM minimizes the penalized negative log likelihood:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\min_{\\beta_0, \\beta} \\frac{1}{N}</span>
<span class="sd">        \\sum_{i = 1}^N \\mathcal{L} (y_i, \\beta_0 + \\beta^T x_i)</span>
<span class="sd">        + \\lambda [ \\frac{1}{2}(1 - \\alpha) \\mathcal{P}_2 +</span>
<span class="sd">                    \\alpha \\mathcal{P}_1 ]</span>

<span class="sd">    where :math:`\\mathcal{P}_2` and :math:`\\mathcal{P}_1` are the generalized</span>
<span class="sd">    L2 (Tikhonov) and generalized L1 (Group Lasso) penalties, given by:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\mathcal{P}_2 = \\|\\Gamma \\beta \\|_2^2 \\</span>
<span class="sd">        \\mathcal{P}_1 = \\sum_g \\|\\beta_{j,g}\\|_2</span>

<span class="sd">    where :math:`\\Gamma` is the Tikhonov matrix: a square factorization</span>
<span class="sd">    of the inverse covariance matrix and :math:`\\beta_{j,g}` is the</span>
<span class="sd">    :math:`j` th coefficient of group :math:`g`.</span>

<span class="sd">    The generalized L2 penalty defaults to the ridge penalty when</span>
<span class="sd">    :math:`\\Gamma` is identity.</span>

<span class="sd">    The generalized L1 penalty defaults to the lasso penalty when each</span>
<span class="sd">    :math:`\\beta` belongs to its own group.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    distr: str</span>
<span class="sd">        distribution family can be one of the following</span>
<span class="sd">        &#39;gaussian&#39; | &#39;binomial&#39; | &#39;poisson&#39; | &#39;softplus&#39; | &#39;probit&#39; | &#39;gamma&#39;</span>
<span class="sd">        default: &#39;poisson&#39;.</span>
<span class="sd">    alpha: float</span>
<span class="sd">        the weighting between L1 penalty and L2 penalty term</span>
<span class="sd">        of the loss function.</span>
<span class="sd">        default: 0.5</span>
<span class="sd">    Tau: array | None</span>
<span class="sd">        the (n_features, n_features) Tikhonov matrix.</span>
<span class="sd">        default: None, in which case Tau is identity</span>
<span class="sd">        and the L2 penalty is ridge-like</span>
<span class="sd">    group: array | list | None</span>
<span class="sd">        the (n_features, )</span>
<span class="sd">        list or array of group identities for each parameter :math:`\\beta`.</span>
<span class="sd">        Each entry of the list/ array should contain an int from 1 to n_groups</span>
<span class="sd">        that specify group membership for each parameter</span>
<span class="sd">        (except :math:`\\beta_0`).</span>
<span class="sd">        If you do not want to specify a group for a specific parameter,</span>
<span class="sd">        set it to zero.</span>
<span class="sd">        default: None, in which case it defaults to L1 regularization</span>
<span class="sd">    reg_lambda: float</span>
<span class="sd">        regularization parameter :math:`\\lambda` of penalty term.</span>
<span class="sd">        default: 0.1</span>
<span class="sd">    solver: str</span>
<span class="sd">        optimization method, can be one of the following</span>
<span class="sd">        &#39;batch-gradient&#39; (vanilla batch gradient descent)</span>
<span class="sd">        &#39;cdfast&#39; (Newton coordinate gradient descent).</span>
<span class="sd">        default: &#39;batch-gradient&#39;</span>
<span class="sd">    learning_rate: float</span>
<span class="sd">        learning rate for gradient descent.</span>
<span class="sd">        default: 2e-1</span>
<span class="sd">    max_iter: int</span>
<span class="sd">        maximum iterations for the model.</span>
<span class="sd">        default: 1000</span>
<span class="sd">    tol: float</span>
<span class="sd">        convergence threshold or stopping criteria.</span>
<span class="sd">        Optimization loop will stop when norm(gradient) is below the threshold.</span>
<span class="sd">        default: 1e-6</span>
<span class="sd">    eta: float</span>
<span class="sd">        a threshold parameter that linearizes the exp() function above eta.</span>
<span class="sd">        default: 2.0</span>
<span class="sd">    score_metric: str</span>
<span class="sd">        specifies the scoring metric.</span>
<span class="sd">        one of either &#39;deviance&#39; or &#39;pseudo_R2&#39;.</span>
<span class="sd">        default: &#39;deviance&#39;</span>
<span class="sd">    fit_intercept: boolean</span>
<span class="sd">        specifies if a constant (a.k.a. bias or intercept) should be</span>
<span class="sd">        added to the decision function.</span>
<span class="sd">        default: True</span>
<span class="sd">    random_state : int</span>
<span class="sd">        seed of the random number generator used to initialize the solution.</span>
<span class="sd">        default: 0</span>
<span class="sd">    verbose: boolean or int</span>
<span class="sd">        default: False</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    beta0_: int</span>
<span class="sd">        The intercept</span>
<span class="sd">    beta_: array, (n_features)</span>
<span class="sd">        The learned betas</span>
<span class="sd">    n_iter_: int</span>
<span class="sd">        The number of iterations</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; random_state = 1</span>
<span class="sd">    &gt;&gt;&gt; n_samples, n_features = 100, 4</span>
<span class="sd">    &gt;&gt;&gt; rng = np.random.RandomState(random_state)</span>
<span class="sd">    &gt;&gt;&gt; X = rng.normal(0, 1, (n_samples, n_features))</span>
<span class="sd">    &gt;&gt;&gt; y = 2.2 * X[:, 0] -1.0 * X[:, 1] + 0.3 * X[:, 3] + 1.0</span>
<span class="sd">    &gt;&gt;&gt; glm = GLM(distr=&#39;gaussian&#39;, verbose=False, random_state=random_state)</span>
<span class="sd">    &gt;&gt;&gt; glm = glm.fit(X, y)</span>
<span class="sd">    &gt;&gt;&gt; glm.beta0_ # The intercept</span>
<span class="sd">    1.005380485553247</span>
<span class="sd">    &gt;&gt;&gt; glm.beta_ # The coefficients</span>
<span class="sd">    array([ 1.90216711, -0.78782533, -0.        ,  0.03227455])</span>
<span class="sd">    &gt;&gt;&gt; y_pred = glm.predict(X)</span>


<span class="sd">    Reference</span>
<span class="sd">    ---------</span>
<span class="sd">    Friedman, Hastie, Tibshirani (2010). Regularization Paths for Generalized</span>
<span class="sd">        Linear Models via Coordinate Descent, J Statistical Software.</span>
<span class="sd">        https://core.ac.uk/download/files/153/6287975.pdf</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distr</span><span class="o">=</span><span class="s1">&#39;poisson&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                 <span class="n">Tau</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">reg_lambda</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                 <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;batch-gradient&#39;</span><span class="p">,</span>
                 <span class="n">learning_rate</span><span class="o">=</span><span class="mf">2e-1</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                 <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">score_metric</span><span class="o">=</span><span class="s1">&#39;deviance&#39;</span><span class="p">,</span>
                 <span class="n">fit_intercept</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="n">_check_params</span><span class="p">(</span><span class="n">distr</span><span class="o">=</span><span class="n">distr</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span>
                      <span class="n">fit_intercept</span><span class="o">=</span><span class="n">fit_intercept</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">distr</span> <span class="o">=</span> <span class="n">distr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reg_lambda</span> <span class="o">=</span> <span class="n">reg_lambda</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Tau</span> <span class="o">=</span> <span class="n">Tau</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group</span> <span class="o">=</span> <span class="n">group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">solver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span> <span class="o">=</span> <span class="n">learning_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta0_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ynull_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="n">eta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score_metric</span> <span class="o">=</span> <span class="n">score_metric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_intercept</span> <span class="o">=</span> <span class="n">fit_intercept</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="n">set_log_level</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_cv</span><span class="p">(</span><span class="n">cv</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the default CV depending on whether clf</span>
<span class="sd">           is classifier/regressor.&quot;&quot;&quot;</span>
        <span class="c1"># Detect whether classification or regression</span>
        <span class="k">if</span> <span class="n">estimator</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;classifier&#39;</span><span class="p">,</span> <span class="s1">&#39;regressor&#39;</span><span class="p">]:</span>
            <span class="n">est_is_classifier</span> <span class="o">=</span> <span class="n">estimator</span> <span class="o">==</span> <span class="s1">&#39;classifier&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">est_is_classifier</span> <span class="o">=</span> <span class="n">is_classifier</span><span class="p">(</span><span class="n">estimator</span><span class="p">)</span>
        <span class="c1"># Setup CV</span>
        <span class="k">if</span> <span class="n">check_version</span><span class="p">(</span><span class="s1">&#39;sklearn&#39;</span><span class="p">,</span> <span class="s1">&#39;0.18&#39;</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">model_selection</span> <span class="k">as</span> <span class="n">models</span>
            <span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="k">import</span> <span class="p">(</span><span class="n">check_cv</span><span class="p">,</span>
                                                 <span class="n">StratifiedKFold</span><span class="p">,</span> <span class="n">KFold</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cv</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)):</span>
                <span class="n">XFold</span> <span class="o">=</span> <span class="n">StratifiedKFold</span> <span class="k">if</span> <span class="n">est_is_classifier</span> <span class="k">else</span> <span class="n">KFold</span>
                <span class="n">cv</span> <span class="o">=</span> <span class="n">XFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="n">cv</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cv</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="n">cv</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown cross-validation&#39;</span><span class="p">)</span>
                <span class="n">cv</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="n">cv</span><span class="p">)</span>
                <span class="n">cv</span> <span class="o">=</span> <span class="n">cv</span><span class="p">()</span>
            <span class="n">cv</span> <span class="o">=</span> <span class="n">check_cv</span><span class="p">(</span><span class="n">cv</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">classifier</span><span class="o">=</span><span class="n">est_is_classifier</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">cross_validation</span> <span class="k">as</span> <span class="n">models</span>
            <span class="kn">from</span> <span class="nn">sklearn.cross_validation</span> <span class="k">import</span> <span class="p">(</span><span class="n">check_cv</span><span class="p">,</span>
                                                  <span class="n">StratifiedKFold</span><span class="p">,</span> <span class="n">KFold</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cv</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">est_is_classifier</span><span class="p">:</span>
                    <span class="n">cv</span> <span class="o">=</span> <span class="n">StratifiedKFold</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">n_folds</span><span class="o">=</span><span class="n">cv</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cv</span> <span class="o">=</span> <span class="n">KFold</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">n_folds</span><span class="o">=</span><span class="n">cv</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cv</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="n">cv</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown cross-validation&#39;</span><span class="p">)</span>
                <span class="n">cv</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="n">cv</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cv</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;KFold&#39;</span><span class="p">,</span> <span class="s1">&#39;LeaveOneOut&#39;</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;CV cannot be defined with str&#39;</span>
                                              <span class="s1">&#39; for sklearn &lt; .017.&#39;</span><span class="p">)</span>
                <span class="n">cv</span> <span class="o">=</span> <span class="n">cv</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="n">cv</span> <span class="o">=</span> <span class="n">check_cv</span><span class="p">(</span><span class="n">cv</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">classifier</span><span class="o">=</span><span class="n">est_is_classifier</span><span class="p">)</span>

        <span class="c1"># Extract train and test set to retrieve them at predict time</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cv</span><span class="p">,</span> <span class="s1">&#39;split&#39;</span><span class="p">):</span>
            <span class="n">cv_splits</span> <span class="o">=</span> <span class="p">[(</span><span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span> <span class="k">for</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="ow">in</span>
                         <span class="n">cv</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># XXX support sklearn.cross_validation cv</span>
            <span class="n">cv_splits</span> <span class="o">=</span> <span class="p">[(</span><span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">)</span> <span class="k">for</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">cv</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">train</span><span class="p">)</span> <span class="k">for</span> <span class="n">train</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">cv_splits</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Some folds do not have any train epochs.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cv</span><span class="p">,</span> <span class="n">cv_splits</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Description of the object.&quot;&quot;&quot;</span>
        <span class="n">reg_lambda</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg_lambda</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&lt;</span><span class="se">\n</span><span class="s1">Distribution | </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">distr</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">alpha | </span><span class="si">%0.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">max_iter | </span><span class="si">%0.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">lambda: </span><span class="si">%0.2f</span><span class="se">\n</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="n">reg_lambda</span>
        <span class="k">return</span> <span class="n">s</span>

<div class="viewcode-block" id="GLM.copy"><a class="viewcode-back" href="../../api.html#pyglmnet.GLM.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of the object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        none</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self: instance of GLM</span>
<span class="sd">            A copy of the GLM instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_prox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">thresh</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Proximal operator.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">group</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># The default case: soft thresholding</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">-</span> <span class="n">thresh</span><span class="p">)</span> <span class="o">*</span> \
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Group sparsity case: apply group sparsity operator</span>
            <span class="n">group_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="p">)</span>
            <span class="n">group_norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">group_id</span> <span class="ow">in</span> <span class="n">group_ids</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">group_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">group_norms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">group</span> <span class="o">==</span> <span class="n">group_id</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">group</span> <span class="o">==</span> <span class="n">group_id</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>

            <span class="n">nzero_norms</span> <span class="o">=</span> <span class="n">group_norms</span> <span class="o">&gt;</span> <span class="mf">0.0</span>
            <span class="n">over_thresh</span> <span class="o">=</span> <span class="n">group_norms</span> <span class="o">&gt;</span> <span class="n">thresh</span>
            <span class="n">idxs_to_update</span> <span class="o">=</span> <span class="n">nzero_norms</span> <span class="o">&amp;</span> <span class="n">over_thresh</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">beta</span>
            <span class="n">result</span><span class="p">[</span><span class="n">idxs_to_update</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="n">idxs_to_update</span><span class="p">]</span> <span class="o">-</span>
                                      <span class="n">thresh</span> <span class="o">*</span> <span class="n">beta</span><span class="p">[</span><span class="n">idxs_to_update</span><span class="p">]</span> <span class="o">/</span>
                                      <span class="n">group_norms</span><span class="p">[</span><span class="n">idxs_to_update</span><span class="p">])</span>
            <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">idxs_to_update</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_cdfast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ActiveSet</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">rl</span><span class="p">,</span> <span class="n">fit_intercept</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform one cycle of Newton updates for all coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X: array</span>
<span class="sd">            n_samples x n_features</span>
<span class="sd">            The input data</span>
<span class="sd">        y: array</span>
<span class="sd">            Labels to the data</span>
<span class="sd">            n_samples x 1</span>
<span class="sd">        ActiveSet: array</span>
<span class="sd">            n_features + 1 x 1, or n_features</span>
<span class="sd">            Active set storing which betas are non-zero</span>
<span class="sd">        beta: array</span>
<span class="sd">            n_features + 1 x 1, or n_features</span>
<span class="sd">            Parameters to be updated</span>
<span class="sd">        rl: float</span>
<span class="sd">            Regularization lambda</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        beta: array</span>
<span class="sd">            (n_features + 1) x 1, or (n_features)</span>
<span class="sd">            Updated parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_samples</span><span class="p">,</span> <span class="n">n_features</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">reg_scale</span> <span class="o">=</span> <span class="n">rl</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">_z</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">X</span><span class="p">,</span> <span class="n">fit_intercept</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_features</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">fit_intercept</span><span class="p">)):</span>
            <span class="c1"># Only update parameters in active set</span>
            <span class="k">if</span> <span class="n">ActiveSet</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fit_intercept</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">xk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">xk</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xk</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span>

                <span class="c1"># Calculate grad and hess of log likelihood term</span>
                <span class="n">gk</span><span class="p">,</span> <span class="n">hk</span> <span class="o">=</span> <span class="n">_gradhess_logloss_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distr</span><span class="p">,</span> <span class="n">xk</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">,</span>
                                              <span class="n">fit_intercept</span><span class="p">)</span>

                <span class="c1"># Add grad and hess of regularization term</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tau</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">fit_intercept</span><span class="p">:</span>
                        <span class="n">gk_reg</span><span class="p">,</span> <span class="n">hk_reg</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">gk_reg</span><span class="p">,</span> <span class="n">hk_reg</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="mf">1.0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">InvCov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Tau</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tau</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">fit_intercept</span><span class="p">:</span>
                        <span class="n">gk_reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">InvCov</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                        <span class="n">hk_reg</span> <span class="o">=</span> <span class="n">InvCov</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">gk_reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">InvCov</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">beta</span><span class="p">)</span>
                        <span class="n">hk_reg</span> <span class="o">=</span> <span class="n">InvCov</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                <span class="n">gk</span> <span class="o">+=</span> <span class="n">reg_scale</span> <span class="o">*</span> <span class="n">gk_reg</span>
                <span class="n">hk</span> <span class="o">+=</span> <span class="n">reg_scale</span> <span class="o">*</span> <span class="n">hk_reg</span>

                <span class="c1"># Update parameters, z</span>
                <span class="n">update</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">hk</span> <span class="o">*</span> <span class="n">gk</span>
                <span class="n">beta</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">z</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">update</span><span class="p">,</span> <span class="n">z</span> <span class="o">-</span> <span class="n">update</span> <span class="o">*</span> <span class="n">xk</span>
        <span class="k">return</span> <span class="n">beta</span>

<div class="viewcode-block" id="GLM.fit"><a class="viewcode-back" href="../../api.html#pyglmnet.GLM.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The fit function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X: array</span>
<span class="sd">            The 2D input data of shape (n_samples, n_features)</span>

<span class="sd">        y: array</span>
<span class="sd">            The 1D target data of shape (n_samples,)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self: instance of GLM</span>
<span class="sd">            The fitted model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># checks for group</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">group</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">group</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="c1"># shape check</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;group should be (n_features,)&#39;</span><span class="p">)</span>
            <span class="c1"># int check</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;all entries of group should be integers&#39;</span><span class="p">)</span>

        <span class="c1"># type check for data</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Input must be ndarray. Got </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span>
                   <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;X must be a 2D array, got </span><span class="si">%s</span><span class="s2">D&quot;</span> <span class="o">%</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y must be 1D, got </span><span class="si">%s</span><span class="s2">D&quot;</span> <span class="o">%</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_allow_refit&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_allow_refit</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This glm object has already been fit before.&quot;</span>
                             <span class="s2">&quot;A refit is not allowed&quot;</span><span class="p">)</span>

        <span class="n">n_observations</span><span class="p">,</span> <span class="n">n_features</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="n">n_observations</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Shape mismatch.&#39;</span> <span class="o">+</span>
                             <span class="s1">&#39;X has </span><span class="si">{}</span><span class="s1"> observations, y has </span><span class="si">{}</span><span class="s1">.&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_observations</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>

        <span class="c1"># Initialize parameters</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_features</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_intercept</span><span class="p">),))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_intercept</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta0_</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_features</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_features</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n_features</span><span class="p">,</span> <span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta0_</span>
                <span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta0_</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_features</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n_features</span><span class="p">,</span> <span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Lambda: </span><span class="si">%6.4f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg_lambda</span><span class="p">)</span>

        <span class="n">tol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
        <span class="n">reg_lambda</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg_lambda</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;cdfast&#39;</span><span class="p">:</span>
            <span class="c1"># init active set</span>
            <span class="n">ActiveSet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>

        <span class="c1"># Iterative updates</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">beta_old</span> <span class="o">=</span> <span class="n">beta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;batch-gradient&#39;</span><span class="p">:</span>
                <span class="n">grad</span> <span class="o">=</span> <span class="n">_grad_L2loss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distr</span><span class="p">,</span>
                                    <span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tau</span><span class="p">,</span>
                                    <span class="n">reg_lambda</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">,</span>
                                    <span class="n">beta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_intercept</span><span class="p">)</span>
                <span class="c1"># Update</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span> <span class="o">*</span> <span class="n">grad</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;cdfast&#39;</span><span class="p">:</span>
                <span class="n">beta</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cdfast</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ActiveSet</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">reg_lambda</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">fit_intercept</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;solver must be one of &quot;</span>
                                 <span class="s2">&quot;&#39;(&#39;batch-gradient&#39;, &#39;cdfast&#39;), got </span><span class="si">%s</span><span class="s2">.&quot;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">))</span>

            <span class="c1"># Apply proximal operator</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_intercept</span><span class="p">:</span>
                <span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prox</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">reg_lambda</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prox</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">reg_lambda</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">)</span>

            <span class="c1"># Update active set</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s1">&#39;cdfast&#39;</span><span class="p">:</span>
                <span class="n">ActiveSet</span><span class="p">[</span><span class="n">beta</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_intercept</span><span class="p">:</span>
                    <span class="n">ActiveSet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

            <span class="c1"># Convergence by relative parameter change tolerance</span>
            <span class="n">norm_update</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">beta</span> <span class="o">-</span> <span class="n">beta_old</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">norm_update</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">beta</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Parameter update tolerance. &#39;</span> <span class="o">+</span>
                       <span class="s1">&#39;Converged in </span><span class="si">{0:d}</span><span class="s1"> iterations&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="c1"># Compute and save loss if callbacks are requested</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter_</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Reached max number of iterations without convergence.&quot;</span><span class="p">)</span>

        <span class="c1"># Update the estimated variables</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_intercept</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beta0_</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beta_</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beta0_</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beta_</span> <span class="o">=</span> <span class="n">beta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ynull_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_allow_refit</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="GLM.predict"><a class="viewcode-back" href="../../api.html#pyglmnet.GLM.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Predict targets.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X: array</span>
<span class="sd">            Input data for prediction, of shape (n_samples, n_features)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        yhat: array</span>
<span class="sd">            The predicted targets of shape (n_samples,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input data should be of type ndarray (got </span><span class="si">%s</span><span class="s1">).&#39;</span>
                             <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>

        <span class="n">yhat</span> <span class="o">=</span> <span class="n">_lmb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta0_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">,</span>
                    <span class="n">fit_intercept</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distr</span> <span class="o">==</span> <span class="s1">&#39;binomial&#39;</span><span class="p">:</span>
            <span class="n">yhat</span> <span class="o">=</span> <span class="p">(</span><span class="n">yhat</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">yhat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">yhat</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">yhat</span></div>

<div class="viewcode-block" id="GLM.predict_proba"><a class="viewcode-back" href="../../api.html#pyglmnet.GLM.predict_proba">[docs]</a>    <span class="k">def</span> <span class="nf">predict_proba</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Predict class probability for binomial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X: array</span>
<span class="sd">            Input data for prediction, of shape (n_samples, n_features)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        yhat: array</span>
<span class="sd">            The predicted targets of shape (n_samples,).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        Works only for the binomial distribution.</span>
<span class="sd">        Raises error otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;binomial&#39;</span><span class="p">,</span> <span class="s1">&#39;probit&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;This is only applicable for </span><span class="se">\</span>
<span class="s1">                              the binomial distribution.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input data should be of type ndarray (got </span><span class="si">%s</span><span class="s1">).&#39;</span>
                             <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>

        <span class="n">yhat</span> <span class="o">=</span> <span class="n">_lmb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta0_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">,</span>
                    <span class="n">fit_intercept</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">yhat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">yhat</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">yhat</span></div>

<div class="viewcode-block" id="GLM.fit_predict"><a class="viewcode-back" href="../../api.html#pyglmnet.GLM.fit_predict">[docs]</a>    <span class="k">def</span> <span class="nf">fit_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit the model and predict on the same data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X: array</span>
<span class="sd">            The input data to fit and predict,</span>
<span class="sd">            of shape (n_samples, n_features)</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        yhat: array</span>
<span class="sd">            The predicted targets of shape (n_samples,).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>

<div class="viewcode-block" id="GLM.score"><a class="viewcode-back" href="../../api.html#pyglmnet.GLM.score">[docs]</a>    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Score the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X: array</span>
<span class="sd">            The input data whose prediction will be scored,</span>
<span class="sd">            of shape (n_samples, n_features).</span>
<span class="sd">        y: array</span>
<span class="sd">            The true targets against which to score the predicted targets,</span>
<span class="sd">            of shape (n_samples,).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        score: float</span>
<span class="sd">            The score metric</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">metrics</span>
        <span class="n">valid_metrics</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;deviance&#39;</span><span class="p">,</span> <span class="s1">&#39;pseudo_R2&#39;</span><span class="p">,</span> <span class="s1">&#39;accuracy&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_metric</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_metrics</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;score_metric has to be one of: &quot;</span>
                             <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">valid_metrics</span><span class="p">))</span>

        <span class="c1"># If the model has not been fit it cannot be scored</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ynull_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Model must be fit before &#39;</span> <span class="o">+</span>
                             <span class="s1">&#39;prediction can be scored&#39;</span><span class="p">)</span>

        <span class="c1"># For f1 as well</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_metric</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;accuracy&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;binomial&#39;</span><span class="p">,</span> <span class="s1">&#39;multinomial&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">score_metric</span> <span class="o">+</span>
                                 <span class="s1">&#39; is only defined for binomial &#39;</span> <span class="o">+</span>
                                 <span class="s1">&#39;or multinomial distributions&#39;</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distr</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;binomial&#39;</span><span class="p">,</span> <span class="s1">&#39;probit&#39;</span><span class="p">]</span> <span class="ow">and</span> \
           <span class="bp">self</span><span class="o">.</span><span class="n">score_metric</span> <span class="o">!=</span> <span class="s1">&#39;accuracy&#39;</span><span class="p">:</span>
            <span class="n">yhat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">yhat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="c1"># Check whether we have a list of estimators or a single estimator</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_metric</span> <span class="o">==</span> <span class="s1">&#39;deviance&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">metrics</span><span class="o">.</span><span class="n">deviance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">yhat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">distr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_metric</span> <span class="o">==</span> <span class="s1">&#39;pseudo_R2&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">metrics</span><span class="o">.</span><span class="n">pseudo_R2</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yhat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ynull_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">distr</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_metric</span> <span class="o">==</span> <span class="s1">&#39;accuracy&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">metrics</span><span class="o">.</span><span class="n">accuracy</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">yhat</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="GLMCV"><a class="viewcode-back" href="../../api.html#pyglmnet.GLMCV">[docs]</a><span class="k">class</span> <span class="nc">GLMCV</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for estimating regularized generalized linear models (GLM)</span>
<span class="sd">    along a regularization path with warm restarts.</span>

<span class="sd">    The regularized GLM minimizes the penalized negative log likelihood:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\min_{\\beta_0, \\beta} \\frac{1}{N}</span>
<span class="sd">        \\sum_{i = 1}^N \\mathcal{L} (y_i, \\beta_0 + \\beta^T x_i)</span>
<span class="sd">        + \\lambda [ \\frac{1}{2}(1 - \\alpha) \\mathcal{P}_2 +</span>
<span class="sd">                    \\alpha \\mathcal{P}_1 ]</span>

<span class="sd">    where :math:`\\mathcal{P}_2` and :math:`\\mathcal{P}_1` are the generalized</span>
<span class="sd">    L2 (Tikhonov) and generalized L1 (Group Lasso) penalties, given by:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\mathcal{P}_2 = \\|\\Gamma \\beta \\|_2^2 \\</span>
<span class="sd">        \\mathcal{P}_1 = \\sum_g \\|\\beta_{j,g}\\|_2</span>
<span class="sd">    where :math:`\\Gamma` is the Tikhonov matrix: a square factorization</span>
<span class="sd">    of the inverse covariance matrix and :math:`\\beta_{j,g}` is the</span>
<span class="sd">    :math:`j` th coefficient of group :math:`g`.</span>

<span class="sd">    The generalized L2 penalty defaults to the ridge penalty when</span>
<span class="sd">    :math:`\\Gamma` is identity.</span>

<span class="sd">    The generalized L1 penalty defaults to the lasso penalty when each</span>
<span class="sd">    :math:`\\beta` belongs to its own group.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    distr: str</span>
<span class="sd">        distribution family can be one of the following</span>
<span class="sd">        &#39;gaussian&#39; | &#39;binomial&#39; | &#39;poisson&#39; | &#39;softplus&#39; | &#39;probit&#39; | &#39;gamma&#39;</span>
<span class="sd">        default: &#39;poisson&#39;.</span>
<span class="sd">    alpha: float</span>
<span class="sd">        the weighting between L1 penalty and L2 penalty term</span>
<span class="sd">        of the loss function.</span>
<span class="sd">        default: 0.5</span>
<span class="sd">    Tau: array | None</span>
<span class="sd">        the (n_features, n_features) Tikhonov matrix.</span>
<span class="sd">        default: None, in which case Tau is identity</span>
<span class="sd">        and the L2 penalty is ridge-like</span>
<span class="sd">    group: array | list | None</span>
<span class="sd">        the (n_features, )</span>
<span class="sd">        list or array of group identities for each parameter :math:`\\beta`.</span>
<span class="sd">        Each entry of the list/ array should contain an int from 1 to n_groups</span>
<span class="sd">        that specify group membership for each parameter</span>
<span class="sd">        (except :math:`\\beta_0`).</span>
<span class="sd">        If you do not want to specify a group for a specific parameter,</span>
<span class="sd">        set it to zero.</span>
<span class="sd">        default: None, in which case it defaults to L1 regularization</span>
<span class="sd">    reg_lambda: array | list | None</span>
<span class="sd">        array of regularized parameters :math:`\\lambda` of penalty term.</span>
<span class="sd">        default: None, a list of 10 floats spaced logarithmically (base e)</span>
<span class="sd">        between 0.5 and 0.01.</span>
<span class="sd">    cv: cross validation object (default 10)</span>
<span class="sd">        Iterator for doing cross validation</span>
<span class="sd">    solver: str</span>
<span class="sd">        optimization method, can be one of the following</span>
<span class="sd">        &#39;batch-gradient&#39; (vanilla batch gradient descent)</span>
<span class="sd">        &#39;cdfast&#39; (Newton coordinate gradient descent).</span>
<span class="sd">        default: &#39;batch-gradient&#39;</span>
<span class="sd">    learning_rate: float</span>
<span class="sd">        learning rate for gradient descent.</span>
<span class="sd">        default: 2e-1</span>
<span class="sd">    max_iter: int</span>
<span class="sd">        maximum iterations for the model.</span>
<span class="sd">        default: 1000</span>
<span class="sd">    tol: float</span>
<span class="sd">        convergence threshold or stopping criteria.</span>
<span class="sd">        Optimization loop will stop when norm(gradient) is below the threshold.</span>
<span class="sd">        default: 1e-6</span>
<span class="sd">    eta: float</span>
<span class="sd">        a threshold parameter that linearizes the exp() function above eta.</span>
<span class="sd">        default: 2.0</span>
<span class="sd">    score_metric: str</span>
<span class="sd">        specifies the scoring metric.</span>
<span class="sd">        one of either &#39;deviance&#39; or &#39;pseudo_R2&#39;.</span>
<span class="sd">        default: &#39;deviance&#39;</span>
<span class="sd">    fit_intercept: boolean</span>
<span class="sd">        specifies if a constant (a.k.a. bias or intercept) should be</span>
<span class="sd">        added to the decision function.</span>
<span class="sd">        default: True</span>
<span class="sd">    random_state : int</span>
<span class="sd">        seed of the random number generator used to initialize the solution.</span>
<span class="sd">        default: 0</span>
<span class="sd">    verbose: boolean or int</span>
<span class="sd">        default: False</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    beta0_: int</span>
<span class="sd">        The intercept</span>
<span class="sd">    beta_: array, (n_features)</span>
<span class="sd">        The learned betas</span>
<span class="sd">    glm_: instance of GLM</span>
<span class="sd">        The GLM object with best score</span>
<span class="sd">    reg_lambda_opt_: float</span>
<span class="sd">        The reg_lambda parameter for best GLM object</span>
<span class="sd">    n_iter_: int</span>
<span class="sd">        The number of iterations</span>

<span class="sd">    Reference</span>
<span class="sd">    ---------</span>
<span class="sd">    Friedman, Hastie, Tibshirani (2010). Regularization Paths for Generalized</span>
<span class="sd">        Linear Models via Coordinate Descent, J Statistical Software.</span>
<span class="sd">        https://core.ac.uk/download/files/153/6287975.pdf</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    To select subset of fitted glm models, you can simply do:</span>

<span class="sd">    glm = glm[1:3]</span>
<span class="sd">    glm[2].predict(X_test)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distr</span><span class="o">=</span><span class="s1">&#39;poisson&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                 <span class="n">Tau</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">reg_lambda</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;batch-gradient&#39;</span><span class="p">,</span>
                 <span class="n">learning_rate</span><span class="o">=</span><span class="mf">2e-1</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                 <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">score_metric</span><span class="o">=</span><span class="s1">&#39;deviance&#39;</span><span class="p">,</span>
                 <span class="n">fit_intercept</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">reg_lambda</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reg_lambda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">0.01</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span>
                                     <span class="n">base</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reg_lambda</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">reg_lambda</span> <span class="o">=</span> <span class="p">[</span><span class="n">reg_lambda</span><span class="p">]</span>

        <span class="n">_check_params</span><span class="p">(</span><span class="n">distr</span><span class="o">=</span><span class="n">distr</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span>
                      <span class="n">fit_intercept</span><span class="o">=</span><span class="n">fit_intercept</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">distr</span> <span class="o">=</span> <span class="n">distr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reg_lambda</span> <span class="o">=</span> <span class="n">reg_lambda</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv</span> <span class="o">=</span> <span class="n">cv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Tau</span> <span class="o">=</span> <span class="n">Tau</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group</span> <span class="o">=</span> <span class="n">group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">solver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span> <span class="o">=</span> <span class="n">learning_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta0_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reg_lambda_opt_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">glm_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scores_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ynull_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="n">eta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score_metric</span> <span class="o">=</span> <span class="n">score_metric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_intercept</span> <span class="o">=</span> <span class="n">fit_intercept</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="n">set_log_level</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Description of the object.&quot;&quot;&quot;</span>
        <span class="n">reg_lambda</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg_lambda</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&lt;</span><span class="se">\n</span><span class="s1">Distribution | </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">distr</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">alpha | </span><span class="si">%0.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">max_iter | </span><span class="si">%0.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reg_lambda</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">lambda: </span><span class="si">%0.2f</span><span class="s1"> to </span><span class="si">%0.2f</span><span class="se">\n</span><span class="s1">&gt;&#39;</span>
                  <span class="o">%</span> <span class="p">(</span><span class="n">reg_lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reg_lambda</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">lambda: </span><span class="si">%0.2f</span><span class="se">\n</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="n">reg_lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">s</span>

<div class="viewcode-block" id="GLMCV.copy"><a class="viewcode-back" href="../../api.html#pyglmnet.GLMCV.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of the object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        none</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self: instance of GLM</span>
<span class="sd">            A copy of the GLM instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="GLMCV.fit"><a class="viewcode-back" href="../../api.html#pyglmnet.GLMCV.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The fit function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X: array</span>
<span class="sd">            The input data of shape (n_samples, n_features)</span>

<span class="sd">        y: array</span>
<span class="sd">            The target data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self: instance of GLM</span>
<span class="sd">            The fitted model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Looping through the regularization path&#39;</span><span class="p">)</span>
        <span class="n">glms</span><span class="p">,</span> <span class="n">scores</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ynull_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cv must be int. We do not support scikit-learn &#39;</span>
                             <span class="s1">&#39;cv objects at the moment&#39;</span><span class="p">)</span>

        <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">idxs</span><span class="p">)</span>
        <span class="n">cv_splits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">idxs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">rl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reg_lambda</span><span class="p">):</span>
            <span class="n">glm</span> <span class="o">=</span> <span class="n">GLM</span><span class="p">(</span><span class="n">distr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">distr</span><span class="p">,</span>
                      <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                      <span class="n">Tau</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Tau</span><span class="p">,</span>
                      <span class="n">group</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="p">,</span>
                      <span class="n">reg_lambda</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                      <span class="n">solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span>
                      <span class="n">learning_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span>
                      <span class="n">max_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">,</span>
                      <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span>
                      <span class="n">eta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">,</span>
                      <span class="n">score_metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">score_metric</span><span class="p">,</span>
                      <span class="n">fit_intercept</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_intercept</span><span class="p">,</span>
                      <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span>
                      <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Lambda: </span><span class="si">%6.4f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">rl</span><span class="p">)</span>
            <span class="n">glm</span><span class="o">.</span><span class="n">reg_lambda</span> <span class="o">=</span> <span class="n">rl</span>

            <span class="n">scores_fold</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">fold</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv</span><span class="p">):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">cv_splits</span><span class="p">[</span><span class="n">fold</span><span class="p">]</span>
                <span class="n">train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">idxs</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">glm</span><span class="o">.</span><span class="n">beta0_</span><span class="p">,</span> <span class="n">glm</span><span class="o">.</span><span class="n">beta_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta0_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">glm</span><span class="o">.</span><span class="n">beta0_</span><span class="p">,</span> <span class="n">glm</span><span class="o">.</span><span class="n">beta_</span> <span class="o">=</span> <span class="n">glms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">beta0_</span><span class="p">,</span> <span class="n">glms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">beta_</span>

                <span class="n">glm</span><span class="o">.</span><span class="n">n_iter_</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">glm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">train</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">train</span><span class="p">])</span>
                <span class="n">glm</span><span class="o">.</span><span class="n">_allow_refit</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">scores_fold</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">glm</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">val</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">val</span><span class="p">]))</span>
            <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scores_fold</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">glm</span><span class="o">.</span><span class="n">beta0_</span><span class="p">,</span> <span class="n">glm</span><span class="o">.</span><span class="n">beta_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta0_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">glm</span><span class="o">.</span><span class="n">beta0_</span><span class="p">,</span> <span class="n">glm</span><span class="o">.</span><span class="n">beta_</span> <span class="o">=</span> <span class="n">glms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">beta0_</span><span class="p">,</span> <span class="n">glms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">beta_</span>

            <span class="n">glm</span><span class="o">.</span><span class="n">n_iter_</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">glm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">glms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">glm</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">glm</span> <span class="ow">in</span> <span class="n">glms</span><span class="p">:</span>
            <span class="n">glm</span><span class="o">.</span><span class="n">_allow_refit</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Update the estimated variables</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_metric</span> <span class="o">==</span> <span class="s1">&#39;deviance&#39;</span><span class="p">:</span>
            <span class="n">opt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_metric</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;pseudo_R2&#39;</span><span class="p">,</span> <span class="s1">&#39;accuracy&#39;</span><span class="p">]:</span>
            <span class="n">opt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown score_metric: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">score_metric</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">beta0_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_</span> <span class="o">=</span> <span class="n">glms</span><span class="p">[</span><span class="n">opt</span><span class="p">]</span><span class="o">.</span><span class="n">beta0_</span><span class="p">,</span> <span class="n">glms</span><span class="p">[</span><span class="n">opt</span><span class="p">]</span><span class="o">.</span><span class="n">beta_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reg_lambda_opt_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg_lambda</span><span class="p">[</span><span class="n">opt</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">glm_</span> <span class="o">=</span> <span class="n">glms</span><span class="p">[</span><span class="n">opt</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scores_</span> <span class="o">=</span> <span class="n">scores</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="GLMCV.predict"><a class="viewcode-back" href="../../api.html#pyglmnet.GLMCV.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Predict targets.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X: array</span>
<span class="sd">            Input data for prediction, of shape (n_samples, n_features)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        yhat: array</span>
<span class="sd">            The predicted targets of shape based on the model with optimal</span>
<span class="sd">            reg_lambda (n_samples,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">glm_</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>

<div class="viewcode-block" id="GLMCV.predict_proba"><a class="viewcode-back" href="../../api.html#pyglmnet.GLMCV.predict_proba">[docs]</a>    <span class="k">def</span> <span class="nf">predict_proba</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Predict class probability for binomial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X: array</span>
<span class="sd">            Input data for prediction, of shape (n_samples, n_features)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        yhat: array</span>
<span class="sd">            The predicted targets of shape (n_samples, ).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        Works only for the binomial distribution.</span>
<span class="sd">        Raises error otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">glm_</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>

<div class="viewcode-block" id="GLMCV.fit_predict"><a class="viewcode-back" href="../../api.html#pyglmnet.GLMCV.fit_predict">[docs]</a>    <span class="k">def</span> <span class="nf">fit_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit the model and predict on the same data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X: array</span>
<span class="sd">            The input data to fit and predict,</span>
<span class="sd">            of shape (n_samples, n_features)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        yhat: array</span>
<span class="sd">            The predicted targets of shape based on the model with optimal</span>
<span class="sd">            reg_lambda (n_samples,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">glm_</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>

<div class="viewcode-block" id="GLMCV.score"><a class="viewcode-back" href="../../api.html#pyglmnet.GLMCV.score">[docs]</a>    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Score the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X: array</span>
<span class="sd">            The input data whose prediction will be scored,</span>
<span class="sd">            of shape (n_samples, n_features).</span>
<span class="sd">        y: array</span>
<span class="sd">            The true targets against which to score the predicted targets,</span>
<span class="sd">            of shape (n_samples,).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        score: float</span>
<span class="sd">            The score metric for the optimal reg_lambda</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">glm_</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016-2019, Pavan Ramkumar.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../_static/language_data.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>